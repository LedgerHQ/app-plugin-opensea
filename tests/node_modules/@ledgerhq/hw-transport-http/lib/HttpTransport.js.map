{"version":3,"sources":["../src/HttpTransport.js"],"names":["HttpTransport","url","timeout","check","apdu","apduHex","toString","method","headers","Accept","data","JSON","stringify","response","status","body","error","Buffer","from","Promise","resolve","isSupported","fetch","list","listen","_observer","unsubscribe"],"mappings":";;;;;;;;AACA;;;;AACA;;AACA;;;;AACA;;;;;;;;;;;;AAEA;;;IAGqBA,a;;;;;;0FAuBDC,G,EAAaC,O;;;;;;uBACvBF,cAAcG,KAAd,CAAoBF,GAApB,EAAyBC,OAAzB,C;;;iDACC,IAAIF,aAAJ,CAAkBC,GAAlB,C;;;;;;;;;;;;;;;;;AArBT;;;;AA0BA,yBAAYA,GAAZ,EAAyB;AAAA;;AAAA;;AAEvB,UAAKA,GAAL,GAAWA,GAAX;AAFuB;AAGxB;;;;;4FAEcG,I;;;;;;AACPC,uB,GAAUD,KAAKE,QAAL,CAAc,KAAd,C;;AAChB,+BAAI,MAAJ,EAAY,QAAQD,OAApB;;uBACuB,qBAAM;AAC3BE,0BAAQ,MADmB;AAE3BN,uBAAK,KAAKA,GAFiB;AAG3BO,2BAAS;AACPC,4BAAQ,kBADD;AAEP,oCAAgB;AAFT,mBAHkB;AAO3BC,wBAAMC,KAAKC,SAAL,CAAe,EAAEP,gBAAF,EAAf;AAPqB,iBAAN,C;;;AAAjBQ,wB;;sBASFA,SAASC,MAAT,KAAoB,G;;;;;sBAChB,2BACJ,2CAA2CD,SAASC,MADhD,EAEJ,wBAAwBD,SAASC,MAF7B,C;;;;uBAKWD,SAASH,I;;;AAAtBK,oB;;qBACFA,KAAKC,K;;;;;sBAAaD,KAAKC,K;;;AAC3B,+BAAI,MAAJ,EAAY,QAAQD,KAAKL,IAAzB;kDACOO,OAAOC,IAAP,CAAYH,KAAKL,IAAjB,EAAuB,KAAvB,C;;;;;;;;;;;;;;;;;;qCAGQ,CAAE;;;4BAEI;AACrB,aAAOS,QAAQC,OAAR,EAAP;AACD;;;;;;AA/DkBpB,a,CACZqB,W,GAAc;AAAA,SACnBF,QAAQC,OAAR,CAAgB,OAAOE,KAAP,KAAiB,UAAjC,CADmB;AAAA,C;;AADFtB,a,CAKZuB,I,GAAO;AAAA,SAASJ,QAAQC,OAAR,CAAgB,EAAhB,CAAT;AAAA,C;;AALKpB,a,CAMZwB,M,GAAS,UAACC,SAAD;AAAA,SAAmB;AACjCC,iBAAa,uBAAM,CAAE;AADY,GAAnB;AAAA,C;;AANG1B,a,CAUZG,K;sEAAQ,kBAAOF,GAAP;AAAA,QAAoBC,OAApB,uEAAsC,IAAtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACU,qBAAM,EAAED,QAAF,EAAOC,gBAAP,EAAN,CADV;;AAAA;AACPW,oBADO;;AAAA,kBAETA,SAASC,MAAT,KAAoB,GAFX;AAAA;AAAA;AAAA;;AAAA,kBAGL,2BACJ,oCACEb,GADF,GAEE,YAFF,GAGEY,SAASC,MAJP,EAKJ,4BALI,CAHK;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;;;;kBAVId,a","file":"HttpTransport.js","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { TransportError } from \"@ledgerhq/errors\";\nimport axios from \"axios\";\nimport { log } from \"@ledgerhq/logs\";\n\n/**\n * HTTP transport implementation\n */\nexport default class HttpTransport extends Transport<string> {\n  static isSupported = (): Promise<boolean> =>\n    Promise.resolve(typeof fetch === \"function\");\n\n  // this transport is not discoverable\n  static list = (): * => Promise.resolve([]);\n  static listen = (_observer: *) => ({\n    unsubscribe: () => {}\n  });\n\n  static check = async (url: string, timeout: number = 5000) => {\n    const response = await axios({ url, timeout });\n    if (response.status !== 200) {\n      throw new TransportError(\n        \"failed to access HttpTransport(\" +\n          url +\n          \"): status \" +\n          response.status,\n        \"HttpTransportNotAccessible\"\n      );\n    }\n  };\n\n  static async open(url: string, timeout?: number) {\n    await HttpTransport.check(url, timeout);\n    return new HttpTransport(url);\n  }\n\n  url: string;\n\n  constructor(url: string) {\n    super();\n    this.url = url;\n  }\n\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    const apduHex = apdu.toString(\"hex\");\n    log(\"apdu\", \"=> \" + apduHex);\n    const response = await axios({\n      method: \"POST\",\n      url: this.url,\n      headers: {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\"\n      },\n      data: JSON.stringify({ apduHex })\n    });\n    if (response.status !== 200) {\n      throw new TransportError(\n        \"failed to communicate to server. code=\" + response.status,\n        \"HttpTransportStatus\" + response.status\n      );\n    }\n    const body = await response.data;\n    if (body.error) throw body.error;\n    log(\"apdu\", \"<= \" + body.data);\n    return Buffer.from(body.data, \"hex\");\n  }\n\n  setScrambleKey() {}\n\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n"]}