"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.DeviceModel = exports.StartOptions = exports.DEFAULT_START_OPTIONS = void 0;
/** ******************************************************************************
 *  (c) 2020 Zondax GmbH
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ******************************************************************************* */
var pngjs_1 = __importDefault(require("pngjs"));
var fs_extra_1 = __importDefault(require("fs-extra"));
var rfb2_1 = __importDefault(require("rfb2"));
var sleep_1 = __importDefault(require("sleep"));
// @ts-ignore
var hw_transport_http_1 = __importDefault(require("@ledgerhq/hw-transport-http"));
// @ts-ignore
var elfy_1 = __importDefault(require("elfy"));
// @ts-ignore
var grpc_1 = __importDefault(require("./grpc"));
var constants_1 = require("./constants");
var emulator_1 = __importDefault(require("./emulator"));
var Resolve = require('path').resolve;
var rndstr = require('randomstring');
exports.DEFAULT_START_OPTIONS = {
    model: constants_1.DEFAULT_MODEL,
    logging: false,
    X11: false,
    custom: '',
    startDelay: constants_1.DEFAULT_START_DELAY,
    pressDelay: constants_1.DEFAULT_KEY_DELAY
};
var StartOptions = /** @class */ (function () {
    function StartOptions() {
        this.model = 'nanos';
        this.logging = false;
        this.X11 = false;
        this.custom = '';
        this.startDelay = constants_1.DEFAULT_START_DELAY;
        this.pressDelay = 300;
    }
    return StartOptions;
}());
exports.StartOptions = StartOptions;
var DeviceModel = /** @class */ (function () {
    function DeviceModel() {
    }
    return DeviceModel;
}());
exports.DeviceModel = DeviceModel;
var Zemu = /** @class */ (function () {
    function Zemu(elfPath, libElfs, host, vncPort, transportPort) {
        if (libElfs === void 0) { libElfs = {}; }
        if (host === void 0) { host = constants_1.DEFAULT_HOST; }
        if (vncPort === void 0) { vncPort = constants_1.DEFAULT_VNC_PORT; }
        if (transportPort === void 0) { transportPort = constants_1.DEFAULT_TRANSPORT_PORT; }
        this.host = host;
        this.vncPort = vncPort;
        this.transport_url = "http://" + this.host + ":" + transportPort;
        this.elfPath = elfPath;
        this.libElfs = libElfs;
        this.mainMenuSnapshot = null;
        this.vncSession = null;
        if (this.elfPath == null) {
            throw new Error('elfPath cannot be null!');
        }
        if (!fs_extra_1["default"].existsSync(this.elfPath)) {
            throw new Error('elf file was not found! Did you compile?');
        }
        Object.keys(libElfs).forEach(function (libName) {
            if (!fs_extra_1["default"].existsSync(libElfs[libName])) {
                throw new Error('lib elf file was not found! Did you compile?');
            }
        });
        var containerName = constants_1.BASE_NAME + rndstr.generate(5);
        this.emuContainer = new emulator_1["default"](this.elfPath, this.libElfs, constants_1.DEFAULT_EMU_IMG, containerName);
    }
    Zemu.prototype.getSession = function () {
        return this.vncSession;
    };
    Zemu.saveRGBA2Png = function (rect, filename) {
        var png = new pngjs_1["default"].PNG({
            width: rect.width,
            height: rect.height
        });
        png.data = rect.data.slice();
        var buffer = pngjs_1["default"].PNG.sync.write(png, { colorType: 6 });
        fs_extra_1["default"].writeFileSync(filename, buffer);
    };
    Zemu.LoadPng2RGB = function (filename) {
        var tmpBuffer = fs_extra_1["default"].readFileSync(filename);
        return pngjs_1["default"].PNG.sync.read(tmpBuffer);
    };
    Zemu.delay = function (v) {
        if (v) {
            sleep_1["default"].msleep(v);
        }
        else {
            sleep_1["default"].msleep(constants_1.DEFAULT_KEY_DELAY);
        }
    };
    Zemu.sleep = function (ms) {
        return new Promise(function (resolve) { return setTimeout(resolve, ms); });
    };
    Zemu.delayedPromise = function (p, delay) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.race([
                            p,
                            new Promise(function (resolve) {
                                setTimeout(resolve, delay);
                            }),
                        ])];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.stopAllEmuContainers = function () {
        return __awaiter(this, void 0, void 0, function () {
            var timer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        timer = setTimeout(function () {
                            console.log('Could not kill all containers before timeout!');
                            process.exit(1);
                        }, constants_1.KILL_TIMEOUT);
                        return [4 /*yield*/, emulator_1["default"].killContainerByName(constants_1.BASE_NAME)];
                    case 1:
                        _a.sent();
                        clearTimeout(timer);
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.checkAndPullImage = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, emulator_1["default"].checkAndPullImage(constants_1.DEFAULT_EMU_IMG)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.checkElf = function (model, elfPath) {
        var elfCodeNanoS = 0xc0d00001;
        var elfCodeNanoX = 0xc0de0001;
        var elfApp = fs_extra_1["default"].readFileSync(elfPath);
        var elfInfo = elfy_1["default"].parse(elfApp);
        if (elfInfo.entry !== elfCodeNanoS && elfInfo.entry !== elfCodeNanoX) {
            throw new Error('Are you sure is a Nano S/X app ?');
        }
        // FIXME: SDK2.0 entry points have changed
    };
    Zemu.prototype.start = function (options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var _b, e_1;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, Zemu.checkAndPullImage()];
                    case 1:
                        _c.sent();
                        this.startOptions = options;
                        this.log("[ZEMU] Checking ELF");
                        Zemu.checkElf((_a = this.startOptions.model) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MODEL, this.elfPath);
                        _c.label = 2;
                    case 2:
                        _c.trys.push([2, 7, , 8]);
                        return [4 /*yield*/, Zemu.stopAllEmuContainers()];
                    case 3:
                        _c.sent();
                        this.log("[ZEMU] Starting Container");
                        return [4 /*yield*/, this.emuContainer.runContainer(options)];
                    case 4:
                        _c.sent();
                        this.log("[ZEMU] Started Container");
                        // eslint-disable-next-line func-names
                        return [4 /*yield*/, this.connect()["catch"](function (error) {
                                _this.log("[ZEMU] " + error);
                                _this.close();
                            })];
                    case 5:
                        // eslint-disable-next-line func-names
                        _c.sent();
                        this.log("[ZEMU] Get initial snapshot");
                        // Captures main screen
                        _b = this;
                        return [4 /*yield*/, this.snapshot()];
                    case 6:
                        // Captures main screen
                        _b.mainMenuSnapshot = _c.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        e_1 = _c.sent();
                        this.log("[ZEMU] " + e_1);
                        return [3 /*break*/, 8];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    Zemu.prototype.connect = function () {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var waitDelay, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        waitDelay = (_b = (_a = this.startOptions) === null || _a === void 0 ? void 0 : _a.startDelay) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_START_DELAY;
                        this.log("[ZEMU] Wait VNC for " + waitDelay);
                        Zemu.delay(waitDelay);
                        return [4 /*yield*/, this.connectVNC()];
                    case 1:
                        _d.sent();
                        _c = this;
                        return [4 /*yield*/, hw_transport_http_1["default"](this.transport_url).open(this.transport_url)];
                    case 2:
                        _c.transport = _d.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.prototype.log = function (message) {
        var _a, _b;
        if ((_b = (_a = this.startOptions) === null || _a === void 0 ? void 0 : _a.logging) !== null && _b !== void 0 ? _b : false) {
            process.stdout.write(message + "\n");
        }
    };
    Zemu.prototype.connectVNC = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.vncSession = rfb2_1["default"].createConnection({
                            host: _this.host,
                            port: _this.vncPort
                        });
                        _this.log("[ZEMU] VNC Connection created " + _this.host + ":" + _this.vncPort);
                        var tmpVncSession = _this.vncSession;
                        _this.vncSession.on('connect', function () {
                            _this.log("[ZEMU] VNC Session ready");
                            // @ts-ignore
                            tmpVncSession.keyEvent(constants_1.KEYS.LEFT, constants_1.KEYS.NOT_PRESSED);
                            // @ts-ignore
                            tmpVncSession.keyEvent(constants_1.KEYS.RIGHT, constants_1.KEYS.NOT_PRESSED);
                            resolve(true);
                        });
                        var tmpVncPort = _this.vncPort;
                        var tmpHost = _this.host;
                        _this.vncSession.on('error', function (error) {
                            _this.log("[ZEMU] Could not connect to port " + tmpVncPort + "  on " + tmpHost);
                            reject(error);
                        });
                        setTimeout(function () { return reject(new Error('timeout on connectVNC')); }, 10000);
                    })];
            });
        });
    };
    Zemu.prototype.startGRPCServer = function (ip, port, options) {
        if (options === void 0) { options = {}; }
        this.grpcManager = new grpc_1["default"](ip, port, options, this.transport);
        this.grpcManager.startServer();
    };
    Zemu.prototype.stopGRPCServer = function () {
        if (this.grpcManager) {
            this.grpcManager.stopServer();
        }
    };
    Zemu.prototype.close = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log('[ZEMU] Close');
                        return [4 /*yield*/, this.emuContainer.stop()];
                    case 1:
                        _a.sent();
                        if (this.vncSession) {
                            this.vncSession.end();
                        }
                        this.stopGRPCServer();
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.prototype.getTransport = function () {
        return this.transport;
    };
    Zemu.prototype.getWindowRect = function () {
        var _a, _b, _c, _d;
        switch ((_b = (_a = this.startOptions) === null || _a === void 0 ? void 0 : _a.model) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_MODEL) {
            case 'nanos':
                return constants_1.WINDOW_S;
            case 'nanox':
                return constants_1.WINDOW_X;
        }
        throw "model " + ((_d = (_c = this.startOptions) === null || _c === void 0 ? void 0 : _c.model) !== null && _d !== void 0 ? _d : constants_1.DEFAULT_MODEL) + " not recognized";
    };
    Zemu.prototype.snapshot = function (filename) {
        return __awaiter(this, void 0, void 0, function () {
            var vncSession;
            var _this = this;
            return __generator(this, function (_a) {
                vncSession = this.vncSession;
                this.log('[ZEMU] Requested snapshot');
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var session = _this.getSession();
                        if (!session) {
                            throw new Error('Session is null');
                        }
                        session.once('rect', function (rect) {
                            if (filename) {
                                Zemu.saveRGBA2Png(rect, filename);
                            }
                            resolve(rect);
                        });
                        var modelWindow = _this.getWindowRect();
                        // @ts-ignore
                        vncSession.requestUpdate(false, 0, 0, modelWindow.width, modelWindow.height);
                        setTimeout(function () { return reject(new Error('timeout')); }, constants_1.TIMEOUT);
                    })];
            });
        });
    };
    Zemu.prototype.getMainMenuSnapshot = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.mainMenuSnapshot];
            });
        });
    };
    Zemu.prototype.waitUntilScreenIsNot = function (screen, timeout) {
        if (timeout === void 0) { timeout = 10000; }
        return __awaiter(this, void 0, void 0, function () {
            var start, inputSnapshotBufferHex, currentSnapshotBufferHex, elapsed;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        start = new Date();
                        return [4 /*yield*/, screen];
                    case 1:
                        inputSnapshotBufferHex = (_a.sent()).buffer.toString('hex');
                        return [4 /*yield*/, this.snapshot()];
                    case 2:
                        currentSnapshotBufferHex = (_a.sent()).buffer.toString('hex');
                        _a.label = 3;
                    case 3:
                        if (!(inputSnapshotBufferHex === currentSnapshotBufferHex)) return [3 /*break*/, 6];
                        elapsed = new Date() - start;
                        if (elapsed > timeout) {
                            throw "Timeout waiting for screen to change (" + timeout + " ms)";
                        }
                        return [4 /*yield*/, Zemu.delay(100)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, this.snapshot()];
                    case 5:
                        currentSnapshotBufferHex = (_a.sent()).buffer.toString('hex');
                        return [3 /*break*/, 3];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    Zemu.prototype.compareSnapshotsAndAccept = function (path, testcaseName, snapshotCount, backClickCount) {
        if (backClickCount === void 0) { backClickCount = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var snapshotPrefixGolden, snapshotPrefixTmp, localBackClickCount, imageIndex, indexStr, filename, j, j, j, j, img1, img2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        snapshotPrefixGolden = Resolve(path + "/snapshots/" + testcaseName);
                        snapshotPrefixTmp = Resolve(path + "/snapshots-tmp/" + testcaseName);
                        fs_extra_1["default"].ensureDirSync(snapshotPrefixGolden);
                        fs_extra_1["default"].ensureDirSync(snapshotPrefixTmp);
                        localBackClickCount = typeof backClickCount === 'undefined' ? 0 : backClickCount;
                        this.log("[ZEMU] forward: " + snapshotCount + " backwards: " + localBackClickCount);
                        this.log("[ZEMU] golden      " + snapshotPrefixGolden);
                        this.log("[ZEMU] tmp         " + snapshotPrefixTmp);
                        imageIndex = 0;
                        indexStr = '00000';
                        filename = snapshotPrefixTmp + "/" + indexStr + ".png";
                        this.log("[ZEMU] Start       " + filename);
                        return [4 /*yield*/, this.snapshot(filename)
                            // Move forward to the end
                        ];
                    case 1:
                        _a.sent();
                        j = 0;
                        _a.label = 2;
                    case 2:
                        if (!(j < snapshotCount)) return [3 /*break*/, 5];
                        imageIndex += 1;
                        indexStr = ("" + imageIndex).padStart(5, '0');
                        filename = snapshotPrefixTmp + "/" + indexStr + ".png";
                        return [4 /*yield*/, this.clickRight(filename)];
                    case 3:
                        _a.sent();
                        this.log("[ZEMU] Click Right " + filename);
                        _a.label = 4;
                    case 4:
                        j += 1;
                        return [3 /*break*/, 2];
                    case 5:
                        j = 0;
                        _a.label = 6;
                    case 6:
                        if (!(j < localBackClickCount)) return [3 /*break*/, 9];
                        imageIndex += 1;
                        indexStr = ("" + imageIndex).padStart(5, '0');
                        filename = snapshotPrefixTmp + "/" + indexStr + ".png";
                        this.log("[ZEMU] Click Left  " + filename);
                        return [4 /*yield*/, this.clickLeft("" + filename)];
                    case 7:
                        _a.sent();
                        _a.label = 8;
                    case 8:
                        j += 1;
                        return [3 /*break*/, 6];
                    case 9:
                        j = 0;
                        _a.label = 10;
                    case 10:
                        if (!(j < localBackClickCount)) return [3 /*break*/, 13];
                        imageIndex += 1;
                        indexStr = ("" + imageIndex).padStart(5, '0');
                        filename = snapshotPrefixTmp + "/" + indexStr + ".png";
                        this.log("[ZEMU] Click Right " + filename);
                        return [4 /*yield*/, this.clickRight("" + filename)];
                    case 11:
                        _a.sent();
                        _a.label = 12;
                    case 12:
                        j += 1;
                        return [3 /*break*/, 10];
                    case 13:
                        imageIndex += 1;
                        indexStr = ("" + imageIndex).padStart(5, '0');
                        filename = snapshotPrefixTmp + "/" + indexStr + ".png";
                        this.log("[ZEMU] Click Both  " + filename);
                        return [4 /*yield*/, this.clickBoth("" + filename)];
                    case 14:
                        _a.sent();
                        this.log("[ZEMU] Start comparison");
                        for (j = 0; j < imageIndex + 1; j += 1) {
                            indexStr = ("" + j).padStart(5, '0');
                            this.log("[ZEMU] Checked     " + snapshotPrefixTmp + "/" + indexStr + ".png");
                            img1 = Zemu.LoadPng2RGB(snapshotPrefixTmp + "/" + indexStr + ".png");
                            img2 = Zemu.LoadPng2RGB(snapshotPrefixGolden + "/" + indexStr + ".png");
                            if (!img1.data.equals(img2.data)) {
                                throw new Error("Image [" + indexStr + "] do not match!");
                            }
                        }
                        return [2 /*return*/, true];
                }
            });
        });
    };
    Zemu.prototype.clickLeft = function (filename) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_e) {
                this.getSession().keyEvent(constants_1.KEYS.LEFT, constants_1.KEYS.PRESSED);
                Zemu.delay((_b = (_a = this.startOptions) === null || _a === void 0 ? void 0 : _a.pressDelay) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_KEY_DELAY);
                this.getSession().keyEvent(constants_1.KEYS.LEFT, constants_1.KEYS.NOT_PRESSED);
                Zemu.delay((_d = (_c = this.startOptions) === null || _c === void 0 ? void 0 : _c.pressDelay) !== null && _d !== void 0 ? _d : constants_1.DEFAULT_KEY_DELAY);
                return [2 /*return*/, this.snapshot(filename)];
            });
        });
    };
    Zemu.prototype.clickRight = function (filename) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_e) {
                this.getSession().keyEvent(constants_1.KEYS.RIGHT, constants_1.KEYS.PRESSED);
                Zemu.delay((_b = (_a = this.startOptions) === null || _a === void 0 ? void 0 : _a.pressDelay) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_KEY_DELAY);
                this.getSession().keyEvent(constants_1.KEYS.RIGHT, constants_1.KEYS.NOT_PRESSED);
                Zemu.delay((_d = (_c = this.startOptions) === null || _c === void 0 ? void 0 : _c.pressDelay) !== null && _d !== void 0 ? _d : constants_1.DEFAULT_KEY_DELAY);
                return [2 /*return*/, this.snapshot(filename)];
            });
        });
    };
    Zemu.prototype.clickBoth = function (filename) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_e) {
                this.getSession().keyEvent(constants_1.KEYS.LEFT, constants_1.KEYS.PRESSED);
                this.getSession().keyEvent(constants_1.KEYS.RIGHT, constants_1.KEYS.PRESSED);
                Zemu.delay((_b = (_a = this.startOptions) === null || _a === void 0 ? void 0 : _a.pressDelay) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_KEY_DELAY);
                this.getSession().keyEvent(constants_1.KEYS.LEFT, constants_1.KEYS.NOT_PRESSED);
                this.getSession().keyEvent(constants_1.KEYS.RIGHT, constants_1.KEYS.NOT_PRESSED);
                Zemu.delay((_d = (_c = this.startOptions) === null || _c === void 0 ? void 0 : _c.pressDelay) !== null && _d !== void 0 ? _d : constants_1.DEFAULT_KEY_DELAY);
                return [2 /*return*/, this.snapshot(filename)];
            });
        });
    };
    return Zemu;
}());
exports["default"] = Zemu;
